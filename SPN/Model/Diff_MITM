from Model import Common_bricks_for_attacks
import gurobipy as gp
import numpy as np

class MITM(Common_bricks_for_attacks.MILP_bricks):
    def __init__(self, cipher_parameters, licence_parameters, attack_parameters, model):
        super().__init__(cipher_parameters, licence_parameters, model)
        #Attack parameters
        self.structure_rounds = attack_parameters.get('structure_rounds', 4)
        self.structure_first_round_index = 0
        self.structure_last_round_index = self.structure_rounds - 1

        self.upper_rounds = attack_parameters.get('upper_rounds', 2)
        self.upper_part_first_round = self.upper_part_first_round
        self.upper_part_first_round = self.structure_rounds + self.upper_rounds - 1

        self.distinguisher_rounds = attack_parameters.get('distinguisher_rounds', 2)
        self.distinguisher_input = attack_parameters.get('distinguisher_input', 2)
        self.distinguisher_output = attack_parameters.get('distinguisher_output', 2)

        self.lower_rounds = attack_parameters.get('lower_rounds', 2)
        self.lower_part_first_round = self.upper_part_first_round + self.upper_rounds + self.distinguisher_rounds
        self.lower_part_last_round = self.lower_part_first_round + self.lower_rounds - 1

        self.total_rounds = self.structure_rounds + self.upper_rounds + self.lower_rounds + self.distinguisher_rounds
        self.optimal_complexity = attack_parameters.get('optimal_complexity', False)

    def value_variables_initialisation(self):
        self.values = self.model.addVars(range(2), range(2),
                                            range(self.total_rounds),
                                            range(self.state_number),
                                            range(self.block_row_size),
                                            range(self.block_column_size),
                                            range(3), #valeur{0=unknown, 1=can be computed, 2=fixed}
                                            vtype=gp.GRB.BINARY,
                                            name='state')
        
        self.model.addConstrs((gp.quicksum(self.values[part, sens, round_index, state_index, row, column, value] for value in range(3)) == 1 
                                for part in range(2)
                                for sens in range(2)
                                for round_index in range(self.total_rounds)
                                for state_index in range(self.state_number) 
                                for row in range(self.block_row_size) 
                                for column in range(self.block_column_size)), 
                                name='unique_value_in_state_constraints')

        self.model.addConstrs((self.values[part, 0, round_index, state_index, row, column, 2] == self.values[part, 1, round_index, state_index, row, column, 2]
                             for part in range(2)
                             for round_index in range(self.total_rounds)
                             for state_index in range(self.state_number) 
                             for row in range(self.block_row_size) 
                             for column in range(self.block_column_size)), 
                             name='same fix elements in both propagation')
        
        #MC fix values
        for element in self.operation_order:
            if element == 'MC':
                self.XOR_in_mc_values = self.model.addVars((((part, sens, round_index, column) + (xor_combination) + (value,)) 
                                                            for part in range(2)
                                                            for sens in range(2)
                                                            for round_index in range(self.total_rounds)
                                                            for column in range(self.block_column_size)
                                                            for xor_combination in self.column_range[sens][round_index%len(self.matrixes[sens])]   
                                                            for value in range(3)), vtype=gp.GRB.INTEGER, name="fix_in_mc")
                
                self.model.addConstrs((gp.quicksum(self.XOR_in_mc_values[(part, sens, round_index, column) + xor_combination + (value,)] for value in range(3)) == 1 
                                        for part in range(2)
                                        for sens in range(2)
                                        for round_index in range(self.total_rounds)
                                        for column in range(self.block_column_size)
                                        for xor_combination in self.column_range[sens][round_index%len(self.matrixes[sens])]),
                                        name='unique_value_in_mc_fix_constraints')

                self.model.addConstrs((self.XOR_in_mc_values[(part, 0, round_index, column) + xor_combination + (2,)] == self.XOR_in_mc_values[(part, 1, round_index, column) + tuple(map(int,np.bitwise_xor.reduce(np.array(xor_combination)[:,None]*np.array(self.matrixes[1][round_index%len(self.matrixes[1])]), axis=0))) + (2,)]
                                        for part in range(2)
                                        for round_index in range(self.total_rounds)
                                        for column in range(self.block_column_size)
                                        for xor_combination in self.column_range[0][round_index%len(self.matrixes[0])]),
                                        name='same fix for backward and forward propagation')
            
            if element == 'MR':
                self.XOR_in_mr_values = self.model.addVars((((part, sens, round_index, row) + (xor_combination) + (value,)) 
                                                            for part in range(2)
                                                            for sens in range(2)
                                                            for round_index in range(self.total_rounds)
                                                            for row in range(self.block_row_size)
                                                            for xor_combination in self.row_range[sens][round_index%len(self.matrixes[sens])]   
                                                            for value in range(3)), vtype=gp.GRB.INTEGER, name="fix_in_mc")
                
                self.model.addConstrs((gp.quicksum(self.XOR_in_mr_values[(part, sens, round_index, row) + xor_combination + (value,)] for value in range(3)) == 1 
                                        for part in range(2)
                                        for sens in range(2)
                                        for round_index in range(self.total_rounds)
                                        for row in range(self.block_row_size)
                                        for xor_combination in self.row_range[sens][round_index%len(self.matrixes[sens])]),
                                        name='unique_value_in_mc_fix_constraints')

                self.model.addConstrs((self.XOR_in_mr_values[(part, 0, round_index, row) + xor_combination + (2,)] == self.XOR_in_mr_values[(part, 1, round_index, row) + tuple(map(int,np.bitwise_xor.reduce(np.array(xor_combination)[:,None]*np.array(self.matrixes[1][round_index%len(self.matrixes[1])]), axis=1))) + (2,)]
                                        for part in range(2)
                                        for round_index in range(self.total_rounds)
                                        for row in range(self.block_row_size)
                                        for xor_combination in self.row_range[0][round_index%len(self.matrixes[0])]),
                                        name='same fix for backward and forward propagation')
            